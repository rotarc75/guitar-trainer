<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Accordeur Chromatique</title>
    <style>
        :root {
            --primary: #8b5cf6;
            --success: #10b981;
            --danger: #ef4444;
            --card-bg: rgba(30, 41, 59, 0.9);
            --text-main: #f1f5f9;
        }

        body {
            font-family: 'Segoe UI', Roboto, sans-serif;
            background:
                radial-gradient(at 0% 0%, hsla(253,16%,7%,1) 0, transparent 50%),
                radial-gradient(at 50% 0%, hsla(260,39%,30%,1) 0, transparent 50%),
                radial-gradient(at 100% 0%, hsla(300,49%,30%,1) 0, transparent 50%);
            background-color: #0f172a;
            color: var(--text-main);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            min-height: 100vh; margin: 0; padding: 20px;
            overflow: hidden;
        }

        .nav-btn {
            position: absolute; top: 25px; left: 25px;
            text-decoration: none; color: rgba(255, 255, 255, 0.8);
            font-weight: 600; padding: 8px 15px;
            background: rgba(255, 255, 255, 0.1); border-radius: 30px;
            border: 1px solid rgba(255,255,255,0.1); transition: all 0.2s;
            z-index: 10;
        }
        .nav-btn:hover { background: rgba(255, 255, 255, 0.25); color: white; }

        .tuner-body {
            position: relative;
            width: 350px;
            height: 400px;
            background: var(--card-bg);
            border-radius: 40px;
            box-shadow: 0 30px 60px -12px rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(20px);
            display: flex; flex-direction: column; align-items: center;
            padding-top: 40px;
        }

        /* NOTE DISPLAY */
        .note-display {
            font-size: 6rem; font-weight: 900;
            color: #94a3b8; /* Gris par d√©faut */
            text-shadow: 0 0 20px rgba(0,0,0,0.5);
            height: 120px; line-height: 120px;
            transition: color 0.2s;
        }

        .note-display.in-tune { color: var(--success); text-shadow: 0 0 30px var(--success); }
        .note-display.active { color: white; }

        .frequency-display {
            font-family: 'Courier New', monospace;
            color: #cbd5e1; font-size: 1.2rem; margin-bottom: 20px; opacity: 0.7;
        }

        /* GAUGE CANVAS */
        canvas { margin-top: 10px; }

        /* INDICATORS */
        .indicators {
            display: flex; justify-content: space-between; width: 100%; padding: 0 40px;
            margin-top: 20px; font-weight: bold; color: #64748b;
        }
        .flat { color: var(--danger); opacity: 0.3; }
        .sharp { color: var(--danger); opacity: 0.3; }

        .flat.active { opacity: 1; text-shadow: 0 0 15px var(--danger); }
        .sharp.active { opacity: 1; text-shadow: 0 0 15px var(--danger); }

        /* START BUTTON */
        .start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 23, 42, 0.95);
            display: flex; align-items: center; justify-content: center;
            border-radius: 40px; z-index: 50; transition: opacity 0.5s;
        }

        .start-btn {
            background: var(--primary); color: white; border: none;
            padding: 20px 40px; font-size: 1.5rem; font-weight: bold; border-radius: 50px;
            cursor: pointer; box-shadow: 0 0 30px rgba(139, 92, 246, 0.5);
            transition: transform 0.2s;
        }
        .start-btn:hover { transform: scale(1.05); }

        .sensitivity-control {
            margin-top: 25px;
            width: 80%;
            display: flex; flex-direction: column; align-items: center;
        }
        .sensitivity-control label {
            color: #94a3b8; font-size: 0.9rem; margin-bottom: 10px; font-weight: bold;
        }
        .sensitivity-control input[type=range] {
            width: 100%; accent-color: var(--primary); cursor: pointer;
        }

    </style>
</head>
<body>

    <a href="../section_outils.html" class="nav-btn">‚Üê Accueil</a>

    <div class="tuner-body">

        <div class="note-display" id="noteName">-</div>
        <div class="frequency-display"><span id="freqValue">0.0</span> Hz</div>

        <canvas id="tunerCanvas" width="300" height="150"></canvas>

        <div class="indicators">
            <span id="flatInd" class="flat">‚ô≠ TROP GRAVE</span>
            <span id="sharpInd" class="sharp">TROP AIGU ‚ôØ</span>
        </div>

        <div class="sensitivity-control">
            <label>Seuil de bruit (Noise Gate)</label>
            <input type="range" id="sensGate" min="1" max="30" value="10">
        </div>

        <div class="start-overlay" id="overlay">
            <button class="start-btn" onclick="startTuner()">Activer le Micro üéôÔ∏è</button>
        </div>
    </div>

<script>
    // --- AUDIO CONTEXT & VARIABLES ---
    let audioContext = null;
    let analyser = null;
    let mediaStreamSource = null;
    let bufferLength = 2048; // Taille du buffer pour l'analyse (Plus c'est grand, mieux c'est pour les basses)
    let dataBuffer = null;
    let isRunning = false;

    // --- DOM ELEMENTS ---
    const noteNameEl = document.getElementById('noteName');
    const freqValueEl = document.getElementById('freqValue');
    const flatInd = document.getElementById('flatInd');
    const sharpInd = document.getElementById('sharpInd');
    const canvas = document.getElementById('tunerCanvas');
    const ctx = canvas.getContext('2d');

    // --- CONSTANTES MUSICALES ---
    const noteStrings = ["Do", "Do#", "R√©", "R√©#", "Mi", "Fa", "Fa#", "Sol", "Sol#", "La", "La#", "Si"];

    // --- ETAT VISUEL ---
    let currentCents = 0; // D√©viation actuelle
    let displayCents = 0; // Pour l'animation liss√©e

    async function startTuner() {
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();

            // Demander l'acc√®s au micro
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

            mediaStreamSource = audioContext.createMediaStreamSource(stream);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = bufferLength;

            mediaStreamSource.connect(analyser);

            dataBuffer = new Float32Array(bufferLength);

            document.getElementById('overlay').style.opacity = '0';
            setTimeout(() => document.getElementById('overlay').style.display = 'none', 500);

            isRunning = true;
            updatePitch();
        } catch (err) {
            alert("Erreur: Impossible d'acc√©der au micro. V√©rifie tes permissions !");
            console.error(err);
        }
    }

    // --- ALGORITHME D'AUTOCORR√âLATION ---
    // --- ALGORITHME D'AUTOCORR√âLATION (CORRIG√â) ---
    function autoCorrelate(buf, sampleRate) {
        // 1. Calcul du RMS (Volume moyen du signal)
        let size = buf.length;
        let rms = 0;
        for (let i = 0; i < size; i++) {
            let val = buf[i];
            rms += val * val;
        }
        rms = Math.sqrt(rms / size);

        // --- GESTION DU BRUIT (NOISE GATE) ---
        // On r√©cup√®re la valeur du slider d√©fini dans le HTML
        // Si l'√©l√©ment n'existe pas encore (chargement), on met une valeur par d√©faut
        let sensitivityElement = document.getElementById('sensGate');
        let sensitivityVal = sensitivityElement ? sensitivityElement.value : 10;

        // On convertit la valeur (1-30) en seuil audio (0.001 - 0.030)
        // Plus le slider est haut, plus le seuil est √©lev√© (moins sensible)
        let threshold = sensitivityVal / 1000;

        // Si le volume est inf√©rieur au seuil, on consid√®re que c'est du silence
        if (rms < threshold) return -1;
        // -------------------------------------

        // 2. Pr√©paration du buffer (Trim pour √©viter les erreurs de d√©but/fin)
        let r1 = 0, r2 = size - 1, thres = 0.2;

        // On avance le d√©but jusqu'√† un signal significatif
        for (let i = 0; i < size / 2; i++) {
            if (Math.abs(buf[i]) < thres) { r1 = i; break; }
        }
        // On recule la fin jusqu'√† un signal significatif
        for (let i = 1; i < size / 2; i++) {
            if (Math.abs(buf[size - i]) < thres) { r2 = size - i; break; }
        }

        buf = buf.slice(r1, r2);
        size = buf.length;

        // 3. Calcul de l'autocorr√©lation (Comparaison du signal avec lui-m√™me)
        let c = new Array(size).fill(0);
        for (let i = 0; i < size; i++) {
            for (let j = 0; j < size - i; j++) {
                c[i] = c[i] + buf[j] * buf[j + i];
            }
        }

        // 4. Recherche du pic (La p√©riode fondamentale)
        let d = 0;
        // On ignore la premi√®re descente (le pic √† 0 d√©calage)
        while (c[d] > c[d + 1]) d++;

        let maxval = -1, maxpos = -1;
        for (let i = d; i < size; i++) {
            if (c[i] > maxval) {
                maxval = c[i];
                maxpos = i;
            }
        }
        let T0 = maxpos;

        // 5. Interpolation Parabolique (Pour une pr√©cision chirurgicale)
        // Permet de trouver la fr√©quence exacte "entre" deux √©chantillons
        let x1 = c[T0 - 1], x2 = c[T0], x3 = c[T0 + 1];
        let a = (x1 + x3 - 2 * x2) / 2;
        let b = (x3 - x1) / 2;
        if (a) T0 = T0 - b / (2 * a);

        // Retourne la fr√©quence en Hz
        return sampleRate / T0;
    }




    // --- LOGIQUE MUSICALE ---
    function noteFromPitch(frequency) {
        const noteNum = 12 * (Math.log(frequency / 440) / Math.log(2));
        return Math.round(noteNum) + 69;
    }

    function frequencyFromNoteNumber(note) {
        return 440 * Math.pow(2, (note - 69) / 12);
    }

    function centsOffFromPitch(frequency, note) {
        return Math.floor(1200 * Math.log(frequency / frequencyFromNoteNumber(note)) / Math.log(2));
    }

    // --- BOUCLE PRINCIPALE ---
    function updatePitch() {
        if (!isRunning) return;

        analyser.getFloatTimeDomainData(dataBuffer);
        let ac = autoCorrelate(dataBuffer, audioContext.sampleRate);

        if (ac === -1) {
            // Silence / Bruit -> On relaxe l'aiguille vers 0 doucement
            // Mais on ne change pas la note affich√©e pour √©viter que √ßa clignote
            currentCents *= 0.9;
            freqValueEl.style.opacity = 0.3;
        } else {
            freqValueEl.style.opacity = 1;
            let note = noteFromPitch(ac);
            let noteName = noteStrings[note % 12];

            // Calculer l'√©cart (cents)
            let detune = centsOffFromPitch(ac, note);

            // Limiter l'√©cart √† +/- 50 cents
            if (detune === 0) detune = 0.1; // √©viter division par 0

            noteNameEl.textContent = noteName;
            freqValueEl.textContent = Math.round(ac) + " Hz";

            // Cible
            currentCents = detune;

            // Feedback visuel (Vert si proche de 0)
            if (Math.abs(detune) < 5) {
                noteNameEl.className = "note-display in-tune";
                flatInd.className = "flat";
                sharpInd.className = "sharp";
            } else {
                noteNameEl.className = "note-display active";
                if(detune < 0) {
                    flatInd.className = "flat active";
                    sharpInd.className = "sharp";
                } else {
                    flatInd.className = "flat";
                    sharpInd.className = "sharp active";
                }
            }
        }

        drawGauge();
        requestAnimationFrame(updatePitch);
    }

    // --- DESSIN (CANVAS) ---
    function drawGauge() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        let centerX = canvas.width / 2;
        let centerY = canvas.height - 20;
        let radius = 100;

        // Lissage de l'animation (Lerp)
        displayCents += (currentCents - displayCents) * 0.1;

        // 1. L'arc de fond
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, Math.PI, 2 * Math.PI);
        ctx.lineWidth = 15;
        ctx.strokeStyle = "#334155";
        ctx.stroke();

        // 2. La zone "Juste" (Verte au milieu)
        ctx.beginPath();
        // Petit arc au milieu (-10 cents √† +10 cents)
        let greenStart = Math.PI + Math.PI/2 - 0.15;
        let greenEnd = Math.PI + Math.PI/2 + 0.15;
        ctx.arc(centerX, centerY, radius, greenStart, greenEnd);
        ctx.strokeStyle = "rgba(16, 185, 129, 0.3)"; // Vert transparent
        ctx.stroke();

        // 3. Calcul de l'angle de l'aiguille
        // -50 cents = 180deg (PI), +50 cents = 360deg (2PI)
        // Mais on veut centrer sur PI + PI/2 (Haut)
        let angle = Math.PI + (Math.PI / 2) + (displayCents * (Math.PI / 2) / 50);

        // Limites visuelles
        if (angle < Math.PI) angle = Math.PI;
        if (angle > 2 * Math.PI) angle = 2 * Math.PI;

        // 4. L'aiguille
        let needleLen = radius - 10;
        let needleX = centerX + needleLen * Math.cos(angle);
        let needleY = centerY + needleLen * Math.sin(angle);

        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(needleX, needleY);
        ctx.lineWidth = 4;

        // Couleur de l'aiguille
        if(Math.abs(displayCents) < 5) {
            ctx.strokeStyle = "#10b981"; // Vert
            ctx.shadowColor = "#10b981";
            ctx.shadowBlur = 15;
        } else {
            ctx.strokeStyle = "#ef4444"; // Rouge
            ctx.shadowColor = "#ef4444";
            ctx.shadowBlur = 10;
        }

        ctx.stroke();
        ctx.shadowBlur = 0; // Reset

        // 5. Point pivot
        ctx.beginPath();
        ctx.arc(centerX, centerY, 8, 0, 2 * Math.PI);
        ctx.fillStyle = "white";
        ctx.fill();
    }

</script>
</body>
</html>